{"ast":null,"code":"'use strict';\n\nlet {\n  fileURLToPath,\n  pathToFileURL\n} = require('url');\n\nlet {\n  resolve,\n  isAbsolute\n} = require('path');\n\nlet {\n  SourceMapConsumer,\n  SourceMapGenerator\n} = require('source-map');\n\nlet {\n  nanoid\n} = require('nanoid/non-secure');\n\nlet terminalHighlight = require('./terminal-highlight');\n\nlet CssSyntaxError = require('./css-syntax-error');\n\nlet PreviousMap = require('./previous-map');\n\nlet fromOffsetCache = Symbol('fromOffset cache');\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);\nlet pathAvailable = Boolean(resolve && isAbsolute);\n\nclass Input {\n  constructor(css, opts = {}) {\n    if (css === null || typeof css === 'undefined' || typeof css === 'object' && !css.toString) {\n      throw new Error(`PostCSS received ${css} instead of CSS string`);\n    }\n\n    this.css = css.toString();\n\n    if (this.css[0] === '\\uFEFF' || this.css[0] === '\\uFFFE') {\n      this.hasBOM = true;\n      this.css = this.css.slice(1);\n    } else {\n      this.hasBOM = false;\n    }\n\n    if (opts.from) {\n      if (!pathAvailable || /^\\w+:\\/\\//.test(opts.from) || isAbsolute(opts.from)) {\n        this.file = opts.from;\n      } else {\n        this.file = resolve(opts.from);\n      }\n    }\n\n    if (pathAvailable && sourceMapAvailable) {\n      let map = new PreviousMap(this.css, opts);\n\n      if (map.text) {\n        this.map = map;\n        let file = map.consumer().file;\n        if (!this.file && file) this.file = this.mapResolve(file);\n      }\n    }\n\n    if (!this.file) {\n      this.id = '<input css ' + nanoid(6) + '>';\n    }\n\n    if (this.map) this.map.file = this.from;\n  }\n\n  fromOffset(offset) {\n    let lastLine, lineToIndex;\n\n    if (!this[fromOffsetCache]) {\n      let lines = this.css.split('\\n');\n      lineToIndex = new Array(lines.length);\n      let prevIndex = 0;\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        lineToIndex[i] = prevIndex;\n        prevIndex += lines[i].length + 1;\n      }\n\n      this[fromOffsetCache] = lineToIndex;\n    } else {\n      lineToIndex = this[fromOffsetCache];\n    }\n\n    lastLine = lineToIndex[lineToIndex.length - 1];\n    let min = 0;\n\n    if (offset >= lastLine) {\n      min = lineToIndex.length - 1;\n    } else {\n      let max = lineToIndex.length - 2;\n      let mid;\n\n      while (min < max) {\n        mid = min + (max - min >> 1);\n\n        if (offset < lineToIndex[mid]) {\n          max = mid - 1;\n        } else if (offset >= lineToIndex[mid + 1]) {\n          min = mid + 1;\n        } else {\n          min = mid;\n          break;\n        }\n      }\n    }\n\n    return {\n      line: min + 1,\n      col: offset - lineToIndex[min] + 1\n    };\n  }\n\n  error(message, line, column, opts = {}) {\n    let result;\n\n    if (!column) {\n      let pos = this.fromOffset(line);\n      line = pos.line;\n      column = pos.col;\n    }\n\n    let origin = this.origin(line, column);\n\n    if (origin) {\n      result = new CssSyntaxError(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);\n    } else {\n      result = new CssSyntaxError(message, line, column, this.css, this.file, opts.plugin);\n    }\n\n    result.input = {\n      line,\n      column,\n      source: this.css\n    };\n\n    if (this.file) {\n      if (pathToFileURL) {\n        result.input.url = pathToFileURL(this.file).toString();\n      }\n\n      result.input.file = this.file;\n    }\n\n    return result;\n  }\n\n  origin(line, column) {\n    if (!this.map) return false;\n    let consumer = this.map.consumer();\n    let from = consumer.originalPositionFor({\n      line,\n      column\n    });\n    if (!from.source) return false;\n    let fromUrl;\n\n    if (isAbsolute(from.source)) {\n      fromUrl = pathToFileURL(from.source);\n    } else {\n      fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));\n    }\n\n    let result = {\n      url: fromUrl.toString(),\n      line: from.line,\n      column: from.column\n    };\n\n    if (fromUrl.protocol === 'file:') {\n      if (fileURLToPath) {\n        result.file = fileURLToPath(fromUrl);\n      } else {\n        // istanbul ignore next\n        throw new Error(`file: protocol is not available in this PostCSS build`);\n      }\n    }\n\n    let source = consumer.sourceContentFor(from.source);\n    if (source) result.source = source;\n    return result;\n  }\n\n  mapResolve(file) {\n    if (/^\\w+:\\/\\//.test(file)) {\n      return file;\n    }\n\n    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file);\n  }\n\n  get from() {\n    return this.file || this.id;\n  }\n\n  toJSON() {\n    let json = {};\n\n    for (let name of ['hasBOM', 'css', 'file', 'id']) {\n      if (this[name] != null) {\n        json[name] = this[name];\n      }\n    }\n\n    if (this.map) {\n      json.map = { ...this.map\n      };\n\n      if (json.map.consumerCache) {\n        json.map.consumerCache = undefined;\n      }\n    }\n\n    return json;\n  }\n\n}\n\nmodule.exports = Input;\nInput.default = Input;\n\nif (terminalHighlight && terminalHighlight.registerInput) {\n  terminalHighlight.registerInput(Input);\n}","map":{"version":3,"sources":["/home/swathi_vennela/Documents/Dev/WriterIo-1/BlogApp/frontend/node_modules/sanitize-html/node_modules/postcss/lib/input.js"],"names":["fileURLToPath","pathToFileURL","require","resolve","isAbsolute","SourceMapConsumer","SourceMapGenerator","nanoid","terminalHighlight","CssSyntaxError","PreviousMap","fromOffsetCache","Symbol","sourceMapAvailable","Boolean","pathAvailable","Input","constructor","css","opts","toString","Error","hasBOM","slice","from","test","file","map","text","consumer","mapResolve","id","fromOffset","offset","lastLine","lineToIndex","lines","split","Array","length","prevIndex","i","l","min","max","mid","line","col","error","message","column","result","pos","origin","source","plugin","input","url","originalPositionFor","fromUrl","URL","sourceRoot","mapFile","protocol","sourceContentFor","root","toJSON","json","name","consumerCache","undefined","module","exports","default","registerInput"],"mappings":"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","sourcesContent":["'use strict'\n\nlet { fileURLToPath, pathToFileURL } = require('url')\nlet { resolve, isAbsolute } = require('path')\nlet { SourceMapConsumer, SourceMapGenerator } = require('source-map')\nlet { nanoid } = require('nanoid/non-secure')\n\nlet terminalHighlight = require('./terminal-highlight')\nlet CssSyntaxError = require('./css-syntax-error')\nlet PreviousMap = require('./previous-map')\n\nlet fromOffsetCache = Symbol('fromOffset cache')\n\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)\nlet pathAvailable = Boolean(resolve && isAbsolute)\n\nclass Input {\n  constructor(css, opts = {}) {\n    if (\n      css === null ||\n      typeof css === 'undefined' ||\n      (typeof css === 'object' && !css.toString)\n    ) {\n      throw new Error(`PostCSS received ${css} instead of CSS string`)\n    }\n\n    this.css = css.toString()\n\n    if (this.css[0] === '\\uFEFF' || this.css[0] === '\\uFFFE') {\n      this.hasBOM = true\n      this.css = this.css.slice(1)\n    } else {\n      this.hasBOM = false\n    }\n\n    if (opts.from) {\n      if (\n        !pathAvailable ||\n        /^\\w+:\\/\\//.test(opts.from) ||\n        isAbsolute(opts.from)\n      ) {\n        this.file = opts.from\n      } else {\n        this.file = resolve(opts.from)\n      }\n    }\n\n    if (pathAvailable && sourceMapAvailable) {\n      let map = new PreviousMap(this.css, opts)\n      if (map.text) {\n        this.map = map\n        let file = map.consumer().file\n        if (!this.file && file) this.file = this.mapResolve(file)\n      }\n    }\n\n    if (!this.file) {\n      this.id = '<input css ' + nanoid(6) + '>'\n    }\n    if (this.map) this.map.file = this.from\n  }\n\n  fromOffset(offset) {\n    let lastLine, lineToIndex\n    if (!this[fromOffsetCache]) {\n      let lines = this.css.split('\\n')\n      lineToIndex = new Array(lines.length)\n      let prevIndex = 0\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        lineToIndex[i] = prevIndex\n        prevIndex += lines[i].length + 1\n      }\n\n      this[fromOffsetCache] = lineToIndex\n    } else {\n      lineToIndex = this[fromOffsetCache]\n    }\n    lastLine = lineToIndex[lineToIndex.length - 1]\n\n    let min = 0\n    if (offset >= lastLine) {\n      min = lineToIndex.length - 1\n    } else {\n      let max = lineToIndex.length - 2\n      let mid\n      while (min < max) {\n        mid = min + ((max - min) >> 1)\n        if (offset < lineToIndex[mid]) {\n          max = mid - 1\n        } else if (offset >= lineToIndex[mid + 1]) {\n          min = mid + 1\n        } else {\n          min = mid\n          break\n        }\n      }\n    }\n    return {\n      line: min + 1,\n      col: offset - lineToIndex[min] + 1\n    }\n  }\n\n  error(message, line, column, opts = {}) {\n    let result\n    if (!column) {\n      let pos = this.fromOffset(line)\n      line = pos.line\n      column = pos.col\n    }\n    let origin = this.origin(line, column)\n    if (origin) {\n      result = new CssSyntaxError(\n        message,\n        origin.line,\n        origin.column,\n        origin.source,\n        origin.file,\n        opts.plugin\n      )\n    } else {\n      result = new CssSyntaxError(\n        message,\n        line,\n        column,\n        this.css,\n        this.file,\n        opts.plugin\n      )\n    }\n\n    result.input = { line, column, source: this.css }\n    if (this.file) {\n      if (pathToFileURL) {\n        result.input.url = pathToFileURL(this.file).toString()\n      }\n      result.input.file = this.file\n    }\n\n    return result\n  }\n\n  origin(line, column) {\n    if (!this.map) return false\n    let consumer = this.map.consumer()\n\n    let from = consumer.originalPositionFor({ line, column })\n    if (!from.source) return false\n\n    let fromUrl\n\n    if (isAbsolute(from.source)) {\n      fromUrl = pathToFileURL(from.source)\n    } else {\n      fromUrl = new URL(\n        from.source,\n        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)\n      )\n    }\n\n    let result = {\n      url: fromUrl.toString(),\n      line: from.line,\n      column: from.column\n    }\n\n    if (fromUrl.protocol === 'file:') {\n      if (fileURLToPath) {\n        result.file = fileURLToPath(fromUrl)\n      } else {\n        // istanbul ignore next\n        throw new Error(`file: protocol is not available in this PostCSS build`)\n      }\n    }\n\n    let source = consumer.sourceContentFor(from.source)\n    if (source) result.source = source\n\n    return result\n  }\n\n  mapResolve(file) {\n    if (/^\\w+:\\/\\//.test(file)) {\n      return file\n    }\n    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)\n  }\n\n  get from() {\n    return this.file || this.id\n  }\n\n  toJSON() {\n    let json = {}\n    for (let name of ['hasBOM', 'css', 'file', 'id']) {\n      if (this[name] != null) {\n        json[name] = this[name]\n      }\n    }\n    if (this.map) {\n      json.map = { ...this.map }\n      if (json.map.consumerCache) {\n        json.map.consumerCache = undefined\n      }\n    }\n    return json\n  }\n}\n\nmodule.exports = Input\nInput.default = Input\n\nif (terminalHighlight && terminalHighlight.registerInput) {\n  terminalHighlight.registerInput(Input)\n}\n"]},"metadata":{},"sourceType":"script"}