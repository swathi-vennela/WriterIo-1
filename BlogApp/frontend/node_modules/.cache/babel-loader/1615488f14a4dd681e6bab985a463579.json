{"ast":null,"code":"'use strict';\n\nlet Declaration = require('./declaration');\n\nlet {\n  isClean\n} = require('./symbols');\n\nlet Comment = require('./comment');\n\nlet Node = require('./node');\n\nlet parse, Rule, AtRule;\n\nfunction cleanSource(nodes) {\n  return nodes.map(i => {\n    if (i.nodes) i.nodes = cleanSource(i.nodes);\n    delete i.source;\n    return i;\n  });\n}\n\nfunction markDirtyUp(node) {\n  node[isClean] = false;\n\n  if (node.proxyOf.nodes) {\n    for (let i of node.proxyOf.nodes) {\n      markDirtyUp(i);\n    }\n  }\n} // istanbul ignore next\n\n\nfunction rebuild(node) {\n  if (node.type === 'atrule') {\n    Object.setPrototypeOf(node, AtRule.prototype);\n  } else if (node.type === 'rule') {\n    Object.setPrototypeOf(node, Rule.prototype);\n  } else if (node.type === 'decl') {\n    Object.setPrototypeOf(node, Declaration.prototype);\n  } else if (node.type === 'comment') {\n    Object.setPrototypeOf(node, Comment.prototype);\n  }\n\n  if (node.nodes) {\n    node.nodes.forEach(child => {\n      rebuild(child);\n    });\n  }\n}\n\nclass Container extends Node {\n  push(child) {\n    child.parent = this;\n    this.proxyOf.nodes.push(child);\n    return this;\n  }\n\n  each(callback) {\n    if (!this.proxyOf.nodes) return undefined;\n    let iterator = this.getIterator();\n    let index, result;\n\n    while (this.indexes[iterator] < this.proxyOf.nodes.length) {\n      index = this.indexes[iterator];\n      result = callback(this.proxyOf.nodes[index], index);\n      if (result === false) break;\n      this.indexes[iterator] += 1;\n    }\n\n    delete this.indexes[iterator];\n    return result;\n  }\n\n  walk(callback) {\n    return this.each((child, i) => {\n      let result;\n\n      try {\n        result = callback(child, i);\n      } catch (e) {\n        throw child.addToError(e);\n      }\n\n      if (result !== false && child.walk) {\n        result = child.walk(callback);\n      }\n\n      return result;\n    });\n  }\n\n  walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop;\n      return this.walk((child, i) => {\n        if (child.type === 'decl') {\n          return callback(child, i);\n        }\n      });\n    }\n\n    if (prop instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i);\n        }\n      });\n    }\n\n    return this.walk((child, i) => {\n      if (child.type === 'decl' && child.prop === prop) {\n        return callback(child, i);\n      }\n    });\n  }\n\n  walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector;\n      return this.walk((child, i) => {\n        if (child.type === 'rule') {\n          return callback(child, i);\n        }\n      });\n    }\n\n    if (selector instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i);\n        }\n      });\n    }\n\n    return this.walk((child, i) => {\n      if (child.type === 'rule' && child.selector === selector) {\n        return callback(child, i);\n      }\n    });\n  }\n\n  walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name;\n      return this.walk((child, i) => {\n        if (child.type === 'atrule') {\n          return callback(child, i);\n        }\n      });\n    }\n\n    if (name instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i);\n        }\n      });\n    }\n\n    return this.walk((child, i) => {\n      if (child.type === 'atrule' && child.name === name) {\n        return callback(child, i);\n      }\n    });\n  }\n\n  walkComments(callback) {\n    return this.walk((child, i) => {\n      if (child.type === 'comment') {\n        return callback(child, i);\n      }\n    });\n  }\n\n  append(...children) {\n    for (let child of children) {\n      let nodes = this.normalize(child, this.last);\n\n      for (let node of nodes) this.proxyOf.nodes.push(node);\n    }\n\n    this.markDirty();\n    return this;\n  }\n\n  prepend(...children) {\n    children = children.reverse();\n\n    for (let child of children) {\n      let nodes = this.normalize(child, this.first, 'prepend').reverse();\n\n      for (let node of nodes) this.proxyOf.nodes.unshift(node);\n\n      for (let id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length;\n      }\n    }\n\n    this.markDirty();\n    return this;\n  }\n\n  cleanRaws(keepBetween) {\n    super.cleanRaws(keepBetween);\n\n    if (this.nodes) {\n      for (let node of this.nodes) node.cleanRaws(keepBetween);\n    }\n  }\n\n  insertBefore(exist, add) {\n    exist = this.index(exist);\n    let type = exist === 0 ? 'prepend' : false;\n    let nodes = this.normalize(add, this.proxyOf.nodes[exist], type).reverse();\n\n    for (let node of nodes) this.proxyOf.nodes.splice(exist, 0, node);\n\n    let index;\n\n    for (let id in this.indexes) {\n      index = this.indexes[id];\n\n      if (exist <= index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n\n    this.markDirty();\n    return this;\n  }\n\n  insertAfter(exist, add) {\n    exist = this.index(exist);\n    let nodes = this.normalize(add, this.proxyOf.nodes[exist]).reverse();\n\n    for (let node of nodes) this.proxyOf.nodes.splice(exist + 1, 0, node);\n\n    let index;\n\n    for (let id in this.indexes) {\n      index = this.indexes[id];\n\n      if (exist < index) {\n        this.indexes[id] = index + nodes.length;\n      }\n    }\n\n    this.markDirty();\n    return this;\n  }\n\n  removeChild(child) {\n    child = this.index(child);\n    this.proxyOf.nodes[child].parent = undefined;\n    this.proxyOf.nodes.splice(child, 1);\n    let index;\n\n    for (let id in this.indexes) {\n      index = this.indexes[id];\n\n      if (index >= child) {\n        this.indexes[id] = index - 1;\n      }\n    }\n\n    this.markDirty();\n    return this;\n  }\n\n  removeAll() {\n    for (let node of this.proxyOf.nodes) node.parent = undefined;\n\n    this.proxyOf.nodes = [];\n    this.markDirty();\n    return this;\n  }\n\n  replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts;\n      opts = {};\n    }\n\n    this.walkDecls(decl => {\n      if (opts.props && !opts.props.includes(decl.prop)) return;\n      if (opts.fast && !decl.value.includes(opts.fast)) return;\n      decl.value = decl.value.replace(pattern, callback);\n    });\n    this.markDirty();\n    return this;\n  }\n\n  every(condition) {\n    return this.nodes.every(condition);\n  }\n\n  some(condition) {\n    return this.nodes.some(condition);\n  }\n\n  index(child) {\n    if (typeof child === 'number') return child;\n    if (child.proxyOf) child = child.proxyOf;\n    return this.proxyOf.nodes.indexOf(child);\n  }\n\n  get first() {\n    if (!this.proxyOf.nodes) return undefined;\n    return this.proxyOf.nodes[0];\n  }\n\n  get last() {\n    if (!this.proxyOf.nodes) return undefined;\n    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n  }\n\n  normalize(nodes, sample) {\n    if (typeof nodes === 'string') {\n      nodes = cleanSource(parse(nodes).nodes);\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0);\n\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore');\n      }\n    } else if (nodes.type === 'root') {\n      nodes = nodes.nodes.slice(0);\n\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore');\n      }\n    } else if (nodes.type) {\n      nodes = [nodes];\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation');\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value);\n      }\n\n      nodes = [new Declaration(nodes)];\n    } else if (nodes.selector) {\n      nodes = [new Rule(nodes)];\n    } else if (nodes.name) {\n      nodes = [new AtRule(nodes)];\n    } else if (nodes.text) {\n      nodes = [new Comment(nodes)];\n    } else {\n      throw new Error('Unknown node type in node creation');\n    }\n\n    let processed = nodes.map(i => {\n      // istanbul ignore next\n      if (typeof i.markDirty !== 'function') rebuild(i);\n      i = i.proxyOf;\n      if (i.parent) i.parent.removeChild(i);\n      if (i[isClean]) markDirtyUp(i);\n\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/\\S/g, '');\n        }\n      }\n\n      i.parent = this;\n      return i;\n    });\n    return processed;\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true;\n        node[prop] = value;\n\n        if (prop === 'name' || prop === 'params' || prop === 'selector') {\n          node.markDirty();\n        }\n\n        return true;\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node;\n        } else if (!node[prop]) {\n          return node[prop];\n        } else if (prop === 'each' || typeof prop === 'string' && prop.startsWith('walk')) {\n          return (...args) => {\n            return node[prop](...args.map(i => {\n              if (typeof i === 'function') {\n                return (child, index) => i(child.toProxy(), index);\n              } else {\n                return i;\n              }\n            }));\n          };\n        } else if (prop === 'every' || prop === 'some') {\n          return cb => {\n            return node[prop]((child, ...other) => cb(child.toProxy(), ...other));\n          };\n        } else if (prop === 'root') {\n          return () => node.root().toProxy();\n        } else if (prop === 'nodes') {\n          return node.nodes.map(i => i.toProxy());\n        } else if (prop === 'first' || prop === 'last') {\n          return node[prop].toProxy();\n        } else {\n          return node[prop];\n        }\n      }\n\n    };\n  }\n\n  getIterator() {\n    if (!this.lastEach) this.lastEach = 0;\n    if (!this.indexes) this.indexes = {};\n    this.lastEach += 1;\n    let iterator = this.lastEach;\n    this.indexes[iterator] = 0;\n    return iterator;\n  }\n\n}\n\nContainer.registerParse = dependant => {\n  parse = dependant;\n};\n\nContainer.registerRule = dependant => {\n  Rule = dependant;\n};\n\nContainer.registerAtRule = dependant => {\n  AtRule = dependant;\n};\n\nmodule.exports = Container;\nContainer.default = Container;","map":{"version":3,"sources":["/home/swathi_vennela/Documents/Dev/WriterIo-1/BlogApp/frontend/node_modules/sanitize-html/node_modules/postcss/lib/container.js"],"names":["Declaration","require","isClean","Comment","Node","parse","Rule","AtRule","cleanSource","nodes","map","i","source","markDirtyUp","node","proxyOf","rebuild","type","Object","setPrototypeOf","prototype","forEach","child","Container","push","parent","each","callback","undefined","iterator","getIterator","index","result","indexes","length","walk","e","addToError","walkDecls","prop","RegExp","test","walkRules","selector","walkAtRules","name","walkComments","append","children","normalize","last","markDirty","prepend","reverse","first","unshift","id","cleanRaws","keepBetween","insertBefore","exist","add","splice","insertAfter","removeChild","removeAll","replaceValues","pattern","opts","decl","props","includes","fast","value","replace","every","condition","some","indexOf","sample","Array","isArray","slice","Error","String","text","processed","raws","before","getProxyProcessor","set","get","startsWith","args","toProxy","cb","other","root","lastEach","registerParse","dependant","registerRule","registerAtRule","module","exports","default"],"mappings":"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","sourcesContent":["'use strict'\n\nlet Declaration = require('./declaration')\nlet { isClean } = require('./symbols')\nlet Comment = require('./comment')\nlet Node = require('./node')\n\nlet parse, Rule, AtRule\n\nfunction cleanSource(nodes) {\n  return nodes.map(i => {\n    if (i.nodes) i.nodes = cleanSource(i.nodes)\n    delete i.source\n    return i\n  })\n}\n\nfunction markDirtyUp(node) {\n  node[isClean] = false\n  if (node.proxyOf.nodes) {\n    for (let i of node.proxyOf.nodes) {\n      markDirtyUp(i)\n    }\n  }\n}\n\n// istanbul ignore next\nfunction rebuild(node) {\n  if (node.type === 'atrule') {\n    Object.setPrototypeOf(node, AtRule.prototype)\n  } else if (node.type === 'rule') {\n    Object.setPrototypeOf(node, Rule.prototype)\n  } else if (node.type === 'decl') {\n    Object.setPrototypeOf(node, Declaration.prototype)\n  } else if (node.type === 'comment') {\n    Object.setPrototypeOf(node, Comment.prototype)\n  }\n\n  if (node.nodes) {\n    node.nodes.forEach(child => {\n      rebuild(child)\n    })\n  }\n}\n\nclass Container extends Node {\n  push(child) {\n    child.parent = this\n    this.proxyOf.nodes.push(child)\n    return this\n  }\n\n  each(callback) {\n    if (!this.proxyOf.nodes) return undefined\n    let iterator = this.getIterator()\n\n    let index, result\n    while (this.indexes[iterator] < this.proxyOf.nodes.length) {\n      index = this.indexes[iterator]\n      result = callback(this.proxyOf.nodes[index], index)\n      if (result === false) break\n\n      this.indexes[iterator] += 1\n    }\n\n    delete this.indexes[iterator]\n    return result\n  }\n\n  walk(callback) {\n    return this.each((child, i) => {\n      let result\n      try {\n        result = callback(child, i)\n      } catch (e) {\n        throw child.addToError(e)\n      }\n      if (result !== false && child.walk) {\n        result = child.walk(callback)\n      }\n\n      return result\n    })\n  }\n\n  walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop\n      return this.walk((child, i) => {\n        if (child.type === 'decl') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (prop instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'decl' && child.prop === prop) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector\n\n      return this.walk((child, i) => {\n        if (child.type === 'rule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (selector instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'rule' && child.selector === selector) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name\n      return this.walk((child, i) => {\n        if (child.type === 'atrule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (name instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'atrule' && child.name === name) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkComments(callback) {\n    return this.walk((child, i) => {\n      if (child.type === 'comment') {\n        return callback(child, i)\n      }\n    })\n  }\n\n  append(...children) {\n    for (let child of children) {\n      let nodes = this.normalize(child, this.last)\n      for (let node of nodes) this.proxyOf.nodes.push(node)\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  prepend(...children) {\n    children = children.reverse()\n    for (let child of children) {\n      let nodes = this.normalize(child, this.first, 'prepend').reverse()\n      for (let node of nodes) this.proxyOf.nodes.unshift(node)\n      for (let id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  cleanRaws(keepBetween) {\n    super.cleanRaws(keepBetween)\n    if (this.nodes) {\n      for (let node of this.nodes) node.cleanRaws(keepBetween)\n    }\n  }\n\n  insertBefore(exist, add) {\n    exist = this.index(exist)\n\n    let type = exist === 0 ? 'prepend' : false\n    let nodes = this.normalize(add, this.proxyOf.nodes[exist], type).reverse()\n    for (let node of nodes) this.proxyOf.nodes.splice(exist, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (exist <= index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  insertAfter(exist, add) {\n    exist = this.index(exist)\n\n    let nodes = this.normalize(add, this.proxyOf.nodes[exist]).reverse()\n    for (let node of nodes) this.proxyOf.nodes.splice(exist + 1, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (exist < index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeChild(child) {\n    child = this.index(child)\n    this.proxyOf.nodes[child].parent = undefined\n    this.proxyOf.nodes.splice(child, 1)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (index >= child) {\n        this.indexes[id] = index - 1\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeAll() {\n    for (let node of this.proxyOf.nodes) node.parent = undefined\n    this.proxyOf.nodes = []\n\n    this.markDirty()\n\n    return this\n  }\n\n  replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts\n      opts = {}\n    }\n\n    this.walkDecls(decl => {\n      if (opts.props && !opts.props.includes(decl.prop)) return\n      if (opts.fast && !decl.value.includes(opts.fast)) return\n\n      decl.value = decl.value.replace(pattern, callback)\n    })\n\n    this.markDirty()\n\n    return this\n  }\n\n  every(condition) {\n    return this.nodes.every(condition)\n  }\n\n  some(condition) {\n    return this.nodes.some(condition)\n  }\n\n  index(child) {\n    if (typeof child === 'number') return child\n    if (child.proxyOf) child = child.proxyOf\n    return this.proxyOf.nodes.indexOf(child)\n  }\n\n  get first() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[0]\n  }\n\n  get last() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]\n  }\n\n  normalize(nodes, sample) {\n    if (typeof nodes === 'string') {\n      nodes = cleanSource(parse(nodes).nodes)\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type === 'root') {\n      nodes = nodes.nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type) {\n      nodes = [nodes]\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation')\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value)\n      }\n      nodes = [new Declaration(nodes)]\n    } else if (nodes.selector) {\n      nodes = [new Rule(nodes)]\n    } else if (nodes.name) {\n      nodes = [new AtRule(nodes)]\n    } else if (nodes.text) {\n      nodes = [new Comment(nodes)]\n    } else {\n      throw new Error('Unknown node type in node creation')\n    }\n\n    let processed = nodes.map(i => {\n      // istanbul ignore next\n      if (typeof i.markDirty !== 'function') rebuild(i)\n      i = i.proxyOf\n      if (i.parent) i.parent.removeChild(i)\n      if (i[isClean]) markDirtyUp(i)\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/\\S/g, '')\n        }\n      }\n      i.parent = this\n      return i\n    })\n\n    return processed\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (prop === 'name' || prop === 'params' || prop === 'selector') {\n          node.markDirty()\n        }\n        return true\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (!node[prop]) {\n          return node[prop]\n        } else if (\n          prop === 'each' ||\n          (typeof prop === 'string' && prop.startsWith('walk'))\n        ) {\n          return (...args) => {\n            return node[prop](\n              ...args.map(i => {\n                if (typeof i === 'function') {\n                  return (child, index) => i(child.toProxy(), index)\n                } else {\n                  return i\n                }\n              })\n            )\n          }\n        } else if (prop === 'every' || prop === 'some') {\n          return cb => {\n            return node[prop]((child, ...other) =>\n              cb(child.toProxy(), ...other)\n            )\n          }\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else if (prop === 'nodes') {\n          return node.nodes.map(i => i.toProxy())\n        } else if (prop === 'first' || prop === 'last') {\n          return node[prop].toProxy()\n        } else {\n          return node[prop]\n        }\n      }\n    }\n  }\n\n  getIterator() {\n    if (!this.lastEach) this.lastEach = 0\n    if (!this.indexes) this.indexes = {}\n\n    this.lastEach += 1\n    let iterator = this.lastEach\n    this.indexes[iterator] = 0\n\n    return iterator\n  }\n}\n\nContainer.registerParse = dependant => {\n  parse = dependant\n}\n\nContainer.registerRule = dependant => {\n  Rule = dependant\n}\n\nContainer.registerAtRule = dependant => {\n  AtRule = dependant\n}\n\nmodule.exports = Container\nContainer.default = Container\n"]},"metadata":{},"sourceType":"script"}