{"ast":null,"code":"'use strict';\n\nlet Declaration = require('./declaration');\n\nlet tokenizer = require('./tokenize');\n\nlet Comment = require('./comment');\n\nlet AtRule = require('./at-rule');\n\nlet Root = require('./root');\n\nlet Rule = require('./rule');\n\nclass Parser {\n  constructor(input) {\n    this.input = input;\n    this.root = new Root();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.customProperty = false;\n    this.createTokenizer();\n    this.root.source = {\n      input,\n      start: {\n        offset: 0,\n        line: 1,\n        column: 1\n      }\n    };\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input);\n  }\n\n  parse() {\n    let token;\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1];\n          break;\n\n        case ';':\n          this.freeSemicolon(token);\n          break;\n\n        case '}':\n          this.end(token);\n          break;\n\n        case 'comment':\n          this.comment(token);\n          break;\n\n        case 'at-word':\n          this.atrule(token);\n          break;\n\n        case '{':\n          this.emptyRule(token);\n          break;\n\n        default:\n          this.other(token);\n          break;\n      }\n    }\n\n    this.endFile();\n  }\n\n  comment(token) {\n    let node = new Comment();\n    this.init(node, token[2]);\n    node.source.end = this.getPosition(token[3] || token[2]);\n    let text = token[1].slice(2, -2);\n\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  }\n\n  emptyRule(token) {\n    let node = new Rule();\n    this.init(node, token[2]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  }\n\n  other(start) {\n    let end = false;\n    let type = null;\n    let colon = false;\n    let bracket = null;\n    let brackets = [];\n    let customProperty = start[1].startsWith('--');\n    let tokens = [];\n    let token = start;\n\n    while (token) {\n      type = token[0];\n      tokens.push(token);\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token;\n        brackets.push('}');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty);\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(tokens);\n          return;\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop());\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n\n      token = this.tokenizer.nextToken();\n    }\n\n    if (this.tokenizer.endOfFile()) end = true;\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n\n    if (end && colon) {\n      while (tokens.length) {\n        token = tokens[tokens.length - 1][0];\n        if (token !== 'space' && token !== 'comment') break;\n        this.tokenizer.back(tokens.pop());\n      }\n\n      this.decl(tokens, customProperty);\n    } else {\n      this.unknownWord(tokens);\n    }\n  }\n\n  rule(tokens) {\n    tokens.pop();\n    let node = new Rule();\n    this.init(node, tokens[0][2]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration();\n    this.init(node, tokens[0][2]);\n    let last = tokens[tokens.length - 1];\n\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n\n    node.source.end = this.getPosition(last[3] || last[2]);\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens);\n      node.raws.before += tokens.shift()[1];\n    }\n\n    node.source.start = this.getPosition(tokens[0][2]);\n    node.prop = '';\n\n    while (tokens.length) {\n      let type = tokens[0][0];\n\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n\n      node.prop += tokens.shift()[1];\n    }\n\n    node.raws.between = '';\n    let token;\n\n    while (tokens.length) {\n      token = tokens.shift();\n\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token]);\n        }\n\n        node.raws.between += token[1];\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n\n    let firstSpaces = this.spacesAndCommentsFromStart(tokens);\n    this.precheckMissedSemicolon(tokens);\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true;\n        let string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0);\n        let str = '';\n\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0];\n\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break;\n          }\n\n          str = cache.pop()[1] + str;\n        }\n\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');\n    this.raw(node, 'value', tokens);\n\n    if (hasWord) {\n      node.raws.between += firstSpaces;\n    } else {\n      node.value = firstSpaces + node.value;\n    }\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens);\n    }\n  }\n\n  atrule(token) {\n    let node = new AtRule();\n    node.name = token[1].slice(1);\n\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n\n    this.init(node, token[2]);\n    let type;\n    let prev;\n    let shift;\n    let last = false;\n    let open = false;\n    let params = [];\n    let brackets = [];\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n      type = token[0];\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}');\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2]);\n          this.semicolon = true;\n          break;\n        } else if (type === '{') {\n          open = true;\n          break;\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1;\n            prev = params[shift];\n\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift];\n            }\n\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2]);\n            }\n          }\n\n          this.end(token);\n          break;\n        } else {\n          params.push(token);\n        }\n      } else {\n        params.push(token);\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true;\n        break;\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = this.getPosition(token[3] || token[2]);\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2]);\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock();\n\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1];\n\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1];\n\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces;\n        this.spaces = '';\n      }\n    }\n  } // Helpers\n\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset);\n    return {\n      offset,\n      line: pos.line,\n      column: pos.col\n    };\n  }\n\n  init(node, offset) {\n    this.current.push(node);\n    node.source = {\n      start: this.getPosition(offset),\n      input: this.input\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  }\n\n  raw(node, prop, tokens) {\n    let token, type;\n    let length = tokens.length;\n    let value = '';\n    let clean = true;\n    let next, prev;\n    let pattern = /^([#.|])?(\\w)+/i;\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === 'comment' && node.type === 'rule') {\n        prev = tokens[i - 1];\n        next = tokens[i + 1];\n\n        if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {\n          value += token[1];\n        } else {\n          clean = false;\n        }\n\n        continue;\n      }\n\n      if (type === 'comment' || type === 'space' && i === length - 1) {\n        clean = false;\n      } else {\n        value += token[1];\n      }\n    }\n\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '');\n      node.raws[prop] = {\n        value,\n        raw\n      };\n    }\n\n    node[prop] = value;\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType;\n    let spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  }\n\n  spacesAndCommentsFromStart(tokens) {\n    let next;\n    let spaces = '';\n\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n\n    return spaces;\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType;\n    let spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  }\n\n  stringFrom(tokens, from) {\n    let result = '';\n\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n\n    tokens.splice(from, tokens.length - from);\n    return result;\n  }\n\n  colon(tokens) {\n    let brackets = 0;\n    let token, type, prev;\n\n    for (let [i, element] of tokens.entries()) {\n      token = element;\n      type = token[0];\n\n      if (type === '(') {\n        brackets += 1;\n      }\n\n      if (type === ')') {\n        brackets -= 1;\n      }\n\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n\n      prev = token;\n    }\n\n    return false;\n  } // Errors\n\n\n  unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2]);\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error('Unknown word', tokens[0][2]);\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error('Unexpected }', token[2]);\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  }\n\n  doubleColon(token) {\n    throw this.input.error('Double colon', token[2]);\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', token[2]);\n  }\n\n  precheckMissedSemicolon()\n  /* tokens */\n  {// Hook for Safe Parser\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens);\n    if (colon === false) return;\n    let founded = 0;\n    let token;\n\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    }\n\n    throw this.input.error('Missed semicolon', token[2]);\n  }\n\n}\n\nmodule.exports = Parser;","map":{"version":3,"sources":["/home/swathi_vennela/Documents/Dev/WriterIo-1/BlogApp/frontend/node_modules/sanitize-html/node_modules/postcss/lib/parser.js"],"names":["Declaration","require","tokenizer","Comment","AtRule","Root","Rule","Parser","constructor","input","root","current","spaces","semicolon","customProperty","createTokenizer","source","start","offset","line","column","parse","token","endOfFile","nextToken","freeSemicolon","end","comment","atrule","emptyRule","other","endFile","node","init","getPosition","text","slice","test","raws","left","right","match","selector","between","type","colon","bracket","brackets","startsWith","tokens","push","length","decl","rule","back","pop","unclosedBracket","unknownWord","spacesAndCommentsFromEnd","raw","last","before","shift","prop","firstSpaces","spacesAndCommentsFromStart","precheckMissedSemicolon","i","toLowerCase","important","string","stringFrom","spacesFromEnd","cache","str","j","trim","indexOf","hasWord","some","value","includes","checkMissedSemicolon","name","unnamedAtrule","prev","open","params","afterName","nodes","after","parent","unexpectedClose","unclosedBlock","ownSemicolon","pos","fromOffset","col","clean","next","pattern","reduce","all","lastTokenType","from","result","splice","element","entries","doubleColon","error","founded","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nlet Declaration = require('./declaration')\nlet tokenizer = require('./tokenize')\nlet Comment = require('./comment')\nlet AtRule = require('./at-rule')\nlet Root = require('./root')\nlet Rule = require('./rule')\n\nclass Parser {\n  constructor(input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n    this.customProperty = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { offset: 0, line: 1, column: 1 } }\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  parse() {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  comment(token) {\n    let node = new Comment()\n    this.init(node, token[2])\n    node.source.end = this.getPosition(token[3] || token[2])\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  emptyRule(token) {\n    let node = new Rule()\n    this.init(node, token[2])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  other(start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n    let customProperty = start[1].startsWith('--')\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token\n        brackets.push('}')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      while (tokens.length) {\n        token = tokens[tokens.length - 1][0]\n        if (token !== 'space' && token !== 'comment') break\n        this.tokenizer.back(tokens.pop())\n      }\n      this.decl(tokens, customProperty)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  rule(tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration()\n    this.init(node, tokens[0][2])\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n    node.source.end = this.getPosition(last[3] || last[2])\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = this.getPosition(tokens[0][2])\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n    let firstSpaces = this.spacesAndCommentsFromStart(tokens)\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')\n    this.raw(node, 'value', tokens)\n    if (hasWord) {\n      node.raws.between += firstSpaces\n    } else {\n      node.value = firstSpaces + node.value\n    }\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens)\n    }\n  }\n\n  atrule(token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2])\n\n    let type\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n    let brackets = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n      type = token[0]\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}')\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2])\n          this.semicolon = true\n          break\n        } else if (type === '{') {\n          open = true\n          break\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1\n            prev = params[shift]\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift]\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2])\n            }\n          }\n          this.end(token)\n          break\n        } else {\n          params.push(token)\n        }\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = this.getPosition(token[3] || token[2])\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2])\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset)\n    return {\n      offset,\n      line: pos.line,\n      column: pos.col\n    }\n  }\n\n  init(node, offset) {\n    this.current.push(node)\n    node.source = {\n      start: this.getPosition(offset),\n      input: this.input\n    }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  raw(node, prop, tokens) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n    let pattern = /^([#.|])?(\\w)+/i\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n\n      if (type === 'comment' && node.type === 'rule') {\n        prev = tokens[i - 1]\n        next = tokens[i + 1]\n\n        if (\n          prev[0] !== 'space' &&\n          next[0] !== 'space' &&\n          pattern.test(prev[1]) &&\n          pattern.test(next[1])\n        ) {\n          value += token[1]\n        } else {\n          clean = false\n        }\n\n        continue\n      }\n\n      if (type === 'comment' || (type === 'space' && i === length - 1)) {\n        clean = false\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { value, raw }\n    }\n    node[prop] = value\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  spacesAndCommentsFromStart(tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom(tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  colon(tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let [i, element] of tokens.entries()) {\n      token = element\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  // Errors\n\n  unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2])\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error('Unknown word', tokens[0][2])\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error('Unexpected }', token[2])\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  doubleColon(token) {\n    throw this.input.error('Double colon', token[2])\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', token[2])\n  }\n\n  precheckMissedSemicolon(/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    throw this.input.error('Missed semicolon', token[2])\n  }\n}\n\nmodule.exports = Parser\n"]},"metadata":{},"sourceType":"script"}